         
Write a Python function called 'mutate_individual(individual, pset)' that returns a mutated version of the individual as a tuple (mutated_individual,). 
Include all necessary imports, including random, and include the following line at the start:
from deap import base, creator, tools, gp

Assume 'individual' is a DEAP gp.PrimitiveTree representing a GP individual, and 'pset' is the DEAP PrimitiveSet used to generate it.

Define a mutation probability 'indpb' (probability of mutating each node) inside the function. You may also define other parameters if needed and document them in comments.

The function should mutate nodes in the tree **safely**, respecting their type:
- Nodes can be Primitives (functions), Terminals (variables/constants), or Ephemeral constants.
- You may choose how to mutate each node type (e.g., replacing, modifying, or regenerating), but ensure the mutated individual is still valid in the DEAP GP context.
Use only gp.PrimitiveTree, gp.Primitive, gp.Terminal, and standard Python operations on the tree list.

Do NOT import or reference any DEAP APIs that are not explicitly documented.
Do NOT create GP nodes manually (__class__(), constructors, or factories are forbidden).
The final individual MUST be a valid gp.PrimitiveTree.
Do NOT assume the existence of classes like EphemeralConstant, PrimitiveTree, or helper functions such as get_leaves.
All replacement nodes must be selected from pset.primitives or pset.terminals.
The tree structure (prefix order and arity consistency) must remain valid.
Ephemeral constants must be handled by selecting from pset.terminals, not by instantiation.
Do not assume numeric operations on non-numeric nodes. Do not use any DEAP methods that do not exist.

Always name the copy of the individual "mutated_individual". Use this name consistently in every line. Do not introduce typos or alternative spellings.
Return the mutated individual as a tuple: `(mutated_individual,)`. It must be of type gp.PrimitiveTree. Do not return any other objects or text.
The LLM has freedom to design the mutation strategy, as long as the resulting individual is valid and can be used with DEAP GP algorithms.
Generate Python code that can run immediately with DEAP, using proper imports and variable names. Ensure there are no undefined variables or typos. Check consistency of all variable names.

An example mutation method is given below:
        
from collections.abc import Sequence
from itertools import repeat
from deap import base, creator, tools, gp

mu = 0.0
sigma = 1.0
indpb = 0.1

size = len(individual)
if not isinstance(mu, Sequence):
    mu = repeat(mu, size)
elif len(mu) < size:
    raise IndexError("mu must be at least the size of individual: %d < %d" % (len(mu), size))
if not isinstance(sigma, Sequence):
    sigma = repeat(sigma, size)
elif len(sigma) < size:
    raise IndexError("sigma must be at least the size of individual: %d < %d" % (len(sigma), size))

for i, m, s in zip(range(size), mu, sigma):
    if random.random() < indpb:
        individual[i] += random.gauss(m, s)

return individual,
        
Return raw Python code only as text, do not wrap it in markdown code blocks or backticks. 
After generating the function, print a brief comment for each line explaining its purpose. Confirm that the variable names are consistent.
